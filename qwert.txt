import os
import asyncio
from io import BytesIO
from PIL import Image
from aiogram import types, F
from aiogram.filters import Command
from aiogram.types import FSInputFile
from logger_config import logger
from facenet.facenet_module import FaceNet

# Импорт асинхронного CRUD и сессии
from db.async_engine import AsyncSessionLocal
from db.async_crud import create_photo
from db.async_search_engine import search_face

# Импорт асинхронного VK API
from vk_api import AsyncVkAPI

# Инициализация FaceNet (если он синхронный, его можно оставить таким же)
face_net = FaceNet()

def crop_face(image, box):
    """Вырезает лицо из изображения по координатам."""
    left, top, right, bottom = box
    return image.crop((left, top, right, bottom))

async def start_handler(message: types.Message):
    logger.info("Стартовая команда получена")
    await message.answer("Привет! Пришли фото для поиска похожих лиц.\nДля помощи отправь /help.")

async def help_handler(message: types.Message):
    logger.info("Команда /help получена")
    help_text = (
        "Я бот для поиска похожих лиц.\n"
        "Просто пришли фото с одним лицом, и я попробую найти похожие в базе данных.\n"
        "Если у тебя есть вопросы, пиши!"
    )
    await message.answer(help_text)

async def photo_handler(message: types.Message):
    logger.info("Получено фото")
    photo_obj = message.photo[-1]
    bot = message.bot
    file = await bot.get_file(photo_obj.file_id)
    file_content = await bot.download_file(file.file_path)
    file_buffer = file_content if hasattr(file_content, "read") else BytesIO(file_content)

    try:
        image = Image.open(file_buffer)
    except Exception as e:
        logger.error(f"Ошибка открытия изображения: {e}")
        await message.answer("Не удалось открыть изображение. Проверь формат.")
        return

    boxes = face_net.detect_faces(image)
    if not boxes:
        logger.warning("Лицо не обнаружено")
        await message.answer("Лицо не обнаружено. Попробуй другое фото.")
        return
    if len(boxes) > 1:
        logger.warning("Обнаружено несколько лиц")
        await message.answer("Обнаружено несколько лиц. Пришли фото с одним лицом.")
        return

    face_image = crop_face(image, boxes[0])
    embedding = face_net.extract_embeddings(face_image)

    async with AsyncSessionLocal() as session:
        matches = await search_face(embedding, session)

    if not matches:
        logger.info("Совпадений не найдено")
        await message.answer("Совпадений не найдено.")
        return

    html_content = "<html><body><h2>Найденные совпадения</h2><ul>"
    for match_photo, dist in matches:
        html_content += f'<li><a href="{match_photo.url}">{match_photo.url}</a> (расстояние: {dist:.2f})</li>'
    html_content += "</ul></body></html>"
    html_bytes = html_content.encode('utf-8')
    html_file = FSInputFile(BytesIO(html_bytes), filename="results.html")
    await message.answer_document(html_file, caption="Найденные совпадения")

async def vk_import_handler(message: types.Message):
    logger.info("Команда /vk_import получена. Импорт фотографий из VK и распознавание лиц.")
    token = os.getenv("VK_ACCESS_TOKEN")
    owner_id = os.getenv("OWNER_ID")
    album_id = os.getenv("ALBUM_ID")
    if not token or not owner_id or not album_id:
        await message.answer("Проверьте, что заданы VK_ACCESS_TOKEN, OWNER_ID и ALBUM_ID.")
        return
    try:
        owner_id = int(owner_id)
        album_id = int(album_id)
    except ValueError:
        await message.answer("OWNER_ID и ALBUM_ID должны быть числами.")
        return

    vk_api = AsyncVkAPI()
    try:
        photo_urls = await vk_api.photos_get(token, owner_id, album_id)
    except Exception as e:
        logger.error("Ошибка при получении фотографий из VK", exc_info=True)
        await message.answer(f"Ошибка при получении фотографий: {e}")
        return

    if not photo_urls:
        await message.answer("Фотографии не найдены в указанном альбоме.")
        return

    imported_count = 0
    async with AsyncSessionLocal() as session:
        for url in photo_urls:
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.get(url, timeout=10)
                if response.status_code != 200:
                    logger.error(f"Ошибка загрузки фото по URL: {url}")
                    continue
                image_data = BytesIO(response.content)
                image = Image.open(image_data)
                boxes = face_net.detect_faces(image)
                if not boxes:
                    logger.info(f"Лицо не обнаружено на фото: {url}")
                    continue
                face_img = crop_face(image, boxes[0])
                embedding = face_net.extract_embeddings(face_img)
                embedding_list = embedding[0].tolist()
                await create_photo(session, url, embedding_list)
                await session.commit()
                imported_count += 1
            except Exception as e:
                logger.error(f"Ошибка обработки фото {url}: {e}", exc_info=True)
                await session.rollback()
    await message.answer(f"Импорт завершен. Загружено {imported_count} фотографий.")

async def vk_albums_handler(message: types.Message):
    logger.info("Получена команда /vk_albums")
    token = os.getenv("VK_ACCESS_TOKEN")
    owner_id = os.getenv("VK_OWNER_ID")
    if not token or not owner_id:
        await message.answer("Не заданы VK_ACCESS_TOKEN или VK_OWNER_ID.")
        return
    try:
        owner_id = int(owner_id)
    except ValueError:
        await message.answer("VK_OWNER_ID должен быть числом.")
        return

    vk_api = AsyncVkAPI()
    try:
        albums = await vk_api.album_get(token, owner_id)
    except Exception as e:
        logger.error("Ошибка при получении альбомов", exc_info=True)
        await message.answer(f"Ошибка при получении альбомов: {e}")
        return

    if not albums:
        await message.answer("Альбомы не найдены.")
    else:
        album_list = "\n".join(str(a) for a in albums)
        # Если сообщение слишком длинное, можно отправить его как файл
        if len(album_list) > 4000:
            bio = BytesIO(album_list.encode('utf-8'))
            bio.seek(0)
            await message.answer_document(
                FSInputFile(bio, filename="albums.txt"),
                caption="Найденные альбомы (см. файл)"
            )
        else:
            await message.answer(f"Найденные альбомы:\n{album_list}")

async def vk_photos_handler(message: types.Message):
    logger.info("Получена команда /vk_photos")
    token = os.getenv("VK_ACCESS_TOKEN")
    owner_id = os.getenv("VK_OWNER_ID")
    album_id = os.getenv("VK_ALBUM_ID")
    if not token or not owner_id or not album_id:
        await message.answer("Проверьте, что заданы VK_ACCESS_TOKEN, VK_OWNER_ID и VK_ALBUM_ID.")
        return
    try:
        owner_id = int(owner_id)
        album_id = int(album_id)
    except ValueError:
        await message.answer("VK_OWNER_ID и VK_ALBUM_ID должны быть числами.")
        return

    vk_api = AsyncVkAPI()
    try:
        photos = await vk_api.photos_get(token, owner_id, album_id)
    except Exception as e:
        logger.error("Ошибка при получении фотографий", exc_info=True)
        await message.answer(f"Ошибка при получении фотографий: {e}")
        return

    if not photos:
        await message.answer("Фотографии не найдены.")
    else:
        photo_list = "\n".join(photos)
        if len(photo_list) > 4000:
            bio = BytesIO(photo_list.encode('utf-8'))
            bio.seek(0)
            await message.answer_document(
                FSInputFile(bio, filename="photos.txt"),
                caption="Найденные фото (см. файл)"
            )
        else:
            await message.answer(f"Найденные фото:\n{photo_list}")

# Обработчик для текстовых сообщений (если не команда и не фото)
async def text_handler(message: types.Message):
    logger.info("Получен текст, не являющийся фото")
    if message.text and message.text.startswith("/"):
        return
    await message.answer("Пожалуйста, отправь фото с одним лицом. Для справки пиши /help.")

# Глобальный обработчик ошибок
async def error_handler(update: types.Update, exception: Exception = None) -> bool:
    logger.error(f"Ошибка при обработке обновления: {update}\nОшибка: {exception}")
    return True

# Регистрация обработчиков
def register_handlers(dp):
    dp.message.register(start_handler, Command("start"))
    dp.message.register(help_handler, Command("help"))
    dp.message.register(photo_handler, F.photo)
    dp.message.register(text_handler, F.text & ~F.text.startswith("/"))
    dp.errors.register(error_handler)
    dp.message.register(vk_photos_handler, Command("vk_photos"))
    dp.message.register(vk_albums_handler, Command("vk_albums"))
    dp.message.register(vk_import_handler, Command("vk_import"))
