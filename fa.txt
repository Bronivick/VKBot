from io import BytesIO
from PIL import Image
from aiogram import types, F
from aiogram.filters import Command
from aiogram.types import FSInputFile
from logger import logger

import os
from time import sleep
import requests 

from facenet.facenet_module import FaceNet
from db.engine import SessionLocal
from db.search_engine import search_face

face_net = FaceNet()

def crop_face(image, box):
    """Вырезает лицо из изображения по координатам."""
    left, top, right, bottom = box
    return image.crop((left, top, right, bottom))

async def start_handler(message: types.Message):
    logger.info("Стартовая команда получена")
    await message.answer("Привет! Пришли фото для поиска похожих лиц.\nДля помощи отправь /help.")

async def help_handler(message: types.Message):
    logger.info("Команда /help получена")
    help_text = (
        "Я бот для поиска похожих лиц.\n"
        "Просто пришли фото с одним лицом, и я попробую найти похожие в базе данных.\n"
        "Если у тебя есть вопросы, пиши!"
    )
    await message.answer(help_text)

async def photo_handler(message: types.Message):
    logger.info("Получено фото")
    # Получаем самую большую версию фото
    photo_obj = message.photo[-1]
    bot = message.bot
    file = await bot.get_file(photo_obj.file_id)
    file_content = await bot.download_file(file.file_path)
    
    # Если file_content уже является BytesIO, используем его напрямую
    if hasattr(file_content, "read"):
        file_buffer = file_content
    else:
        from io import BytesIO
        file_buffer = BytesIO(file_content)
    
    try:
        image = Image.open(file_buffer)
    except Exception as e:
        logger.error(f"Ошибка открытия изображения: {e}")
        await message.answer("Не удалось открыть изображение. Проверь формат.")
        return

    # Детектируем лицо
    boxes = face_net.detect_faces(image)
    if not boxes:
        logger.warning("Лицо не обнаружено")
        await message.answer("Лицо не обнаружено. Попробуй другое фото.")
        return
    if len(boxes) > 1:
        logger.warning("Обнаружено несколько лиц")
        await message.answer("Обнаружено несколько лиц. Пришли фото с одним лицом.")
        return

    # Вырезаем лицо и извлекаем эмбеддинг
    face_image = crop_face(image, boxes[0])
    embedding = face_net.extract_embeddings(face_image)

    # Подключаемся к БД, ищем совпадения и закрываем сессию
    session = SessionLocal()
    matches = search_face(embedding, session)
    session.close()

    if not matches:
        logger.info("Совпадений не найдено")
        await message.answer("Совпадений не найдено.")
        return

    # Формируем HTML-страницу с найденными совпадениями
    html_content = "<html><body><h2>Найденные совпадения</h2><ul>"
    for photo_obj, dist in matches:
        html_content += f'<li><a href="{photo_obj.url}">{photo_obj.url}</a> (расстояние: {dist:.2f})</li>'
    html_content += "</ul></body></html>"

    from io import BytesIO
    html_bytes = html_content.encode('utf-8')
    html_file = FSInputFile(BytesIO(html_bytes), filename="results.html")
    await message.answer_document(html_file, caption="Найденные совпадения")
    
# Новый хэндлер для команды /vk_faces
async def vk_faces_handler(message: types.Message):
    logger.info("Команда /vk_faces получена. Запуск парсинга VK и распознавания лиц.")
    
    # Получаем параметры из переменных окружения
    token = os.getenv("VK_ACCESS_TOKEN")
    owner_id = os.getenv("VK_OWNER_ID")
    album_id = os.getenv("VK_ALBUM_ID")
    
    if not token or not owner_id or not album_id:
        await message.answer("Проверьте, что заданы VK_ACCESS_TOKEN, VK_OWNER_ID и VK_ALBUM_ID.")
        return
    
    try:
        owner_id = int(owner_id)
        album_id = int(album_id)
    except ValueError:
        await message.answer("VK_OWNER_ID и VK_ALBUM_ID должны быть числами.")
        return

async def text_handler(message: types.Message):
    logger.info("Получен текст, не являющийся фото")
    await message.answer("Пожалуйста, отправь фото с одним лицом. Для справки пиши /help.")

async def error_handler(update: types.Update, exception: Exception = None) -> bool:
    logger.error(f"Ошибка при обработке обновления: {update}\nОшибка: {exception}")
    return True


class VkAPI:
    def exponentBackoff(self, attempt):
        delay = min(5, 1 * 2 ** attempt)
        logger.info(f"Ожидание {delay} секунд перед повторной попыткой...")
        sleep(delay)
        
    def _predict_data(self, token):
        predicted_data = {
            'access_token': token,
            'v': '5.199'
        }
        api = 'https://api.vk.com/method/'
        return predicted_data, api
    
    def VKRequest(self, api: str, method: str, data: dict, attempt: int = 0):
        try:
            resp = requests.post(url=f'{api}{method}', data=data)
            data = resp.json()
        except Exception as e:
            logger.error("UNKNOWN ERROR", exc_info=True)
            if attempt < 5:
                self.exponentBackoff(attempt)
                return self.VKRequest(api=api, method=method, data=data, attempt=attempt+1)
            else:
                raise e

        if 'error' in data:
            error_code = data['error'].get('error_code')
            if error_code in (6, 9, 603):
                logger.info(f"RETRY {error_code}")
                attempt += 1  
                self.exponentBackoff(attempt)
                return self.VKRequest(api=api, method=method, data=data, attempt=attempt)  

        return data

    def parse_sizes(self, data: list):
        SIZES = ['s', 'm', 'x', 'o', 'p', 'q', 'r', 'y', 'z', 'w']
        max_size = data[0]
        for i in data:
            index = SIZES.index(i.get('type'))
            if index > SIZES.index(max_size.get('type')):
                max_size = i
        return max_size.get('url')
    
    def photosGet(self, token, owner_id, album_id):
        _post_data, api = self._predict_data(token)
        method = 'photos.get'
        _post_data['owner_id'] = -owner_id  # Отрицательный ID для сообществ
        _post_data['album_id'] = album_id
        response = self.VKRequest(api=api, method=method, data=_post_data)
        if 'error' in response:
            raise Exception(f"Ошибка: {response['error']}")
        photo_urls = [self.parse_sizes(photo['sizes']) for photo in response['response']['items']]
        return photo_urls
    
    def albumGet(self, token, owner_id):
        _post_data, api = self._predict_data(token)
        method = 'photos.getAlbums'
        _post_data['owner_id'] = -owner_id
        response = self.VKRequest(api=api, method=method, data=_post_data)
        if 'response' in response and 'items' in response['response']:
            album_ids = [album['id'] for album in response['response']['items']]
            return album_ids
        else:
            return []  # Возвращаем пустой список, если данных нет

# Новые хэндлеры для работы с VK API

# Хэндлер для получения списка альбомов
async def vk_albums_handler(message: types.Message):
    logger.info("Получена команда /vk_albums")
    token = os.getenv("VK_ACCESS_TOKEN")
    owner_id = os.getenv("VK_OWNER_ID")
    if not token or not owner_id:
        await message.answer("Не заданы VK_ACCESS_TOKEN или VK_OWNER_ID в переменных окружения.")
        return
    try:
        owner_id = int(owner_id)
    except ValueError:
        await message.answer("VK_OWNER_ID должен быть числом.")
        return

    vk_api = VkAPI()
    try:
        albums = vk_api.albumGet(token, owner_id)
    except Exception as e:
        logger.error("Ошибка при получении альбомов", exc_info=True)
        await message.answer(f"Ошибка при получении альбомов: {e}")
        return

    if not albums:
        await message.answer("Альбомы не найдены.")
    else:
        album_list = "\n".join(str(a) for a in albums)
        await message.answer(f"Найденные альбомы:\n{album_list}")

# Хэндлер для получения фотографий из альбома
async def vk_photos_handler(message: types.Message):
    logger.info("Получена команда /vk_photos")
    token = os.getenv("VK_ACCESS_TOKEN")
    owner_id = os.getenv("VK_OWNER_ID")
    album_id = os.getenv("VK_ALBUM_ID")  # Можно задать в переменных окружения или передать как аргумент
    if not token or not owner_id or not album_id:
        await message.answer("Проверьте, что заданы VK_ACCESS_TOKEN, VK_OWNER_ID и VK_ALBUM_ID.")
        return
    try:
        owner_id = int(owner_id)
        album_id = int(album_id)
    except ValueError:
        await message.answer("VK_OWNER_ID и VK_ALBUM_ID должны быть числами.")
        return

    vk_api = VkAPI()
    try:
        photos = vk_api.photosGet(token, owner_id, album_id)
    except Exception as e:
        logger.error("Ошибка при получении фотографий", exc_info=True)
        await message.answer(f"Ошибка при получении фотографий: {e}")
        return

    if not photos:
        await message.answer("Фотографии не найдены.")
    else:
        photo_list = "\n".join(photos)
        await message.answer(f"Найденные фото:\n{photo_list}")


def register_handlers(dp):
    dp.message.register(start_handler, Command("start"))
    dp.message.register(help_handler, Command("help"))
    dp.message.register(photo_handler, F.photo)
    dp.message.register(text_handler, F.text)
    dp.errors.register(error_handler)
    dp.message.register(vk_photos_handler, Command("vk_photos"))
    dp.message.register(vk_albums_handler, Command("vk_albums"))
    dp.message.register(vk_faces_handler, Command("vk_faces"))